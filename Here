import asyncio
import logging
import random
import string
import base64
import time
import re
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command, CommandObject
from aiogram.types import BufferedInputFile

# --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
API_TOKEN = '8525811167:AAGRnOjWoJqS_FyhO3fQYPPUhCbhBoZwSQo'

logging.basicConfig(level=logging.INFO)
bot = Bot(token=API_TOKEN)
dp = Dispatcher()
user_settings = {} # –•—Ä–∞–Ω–∏–ª–∏—â–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ (—Å–ª–æ–∏)

# --- –ú–û–î–£–õ–¨ BEAUTIFIER (–£–ª—É—á—à–µ–Ω–∏–µ –∫–æ–¥–∞) ---
class LuaBeautifier:
    def __init__(self, source):
        self.source = source

    def format(self):
        """–ü—Ä–æ—Å—Ç–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç—Å—Ç—É–ø–æ–≤ –¥–ª—è Lua"""
        code = self.source
        # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã –≤ –Ω–∞—á–∞–ª–µ/–∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫
        lines = [line.strip() for line in code.splitlines() if line.strip()]
        
        formatted = []
        indent = 0
        indent_str = "    " # 4 –ø—Ä–æ–±–µ–ª–∞
        
        # –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞, —É–≤–µ–ª–∏—á–∏–≤–∞—é—â–∏–µ –æ—Ç—Å—Ç—É–ø
        up_keywords = ['function', 'do', 'then', 'repeat', '{', '(', 'if']
        # –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞, —É–º–µ–Ω—å—à–∞—é—â–∏–µ –æ—Ç—Å—Ç—É–ø
        down_keywords = ['end', 'until', '}', ')', 'elseif']
        
        for line in lines:
            curr_line_lower = line.lower()
            
            # –ï—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–≥–æ —Å–ª–æ–≤–∞
            if any(curr_line_lower.startswith(k) for k in ['end', 'until', '}', ')', 'elseif', 'else']):
                indent = max(0, indent - 1)
            
            formatted.append((indent_str * indent) + line)
            
            open_count = sum(1 for k in up_keywords if k in curr_line_lower)
            close_count = sum(1 for k in down_keywords if k in curr_line_lower)
            
            if 'function' in curr_line_lower and 'end' in curr_line_lower:
                pass
            elif 'then' in curr_line_lower and 'end' in curr_line_lower:
                pass
            else:
                if open_count > close_count:
                    indent += 1
                elif 'else' == curr_line_lower: 
                    indent += 1

        return "\n".join(formatted)

# --- MELOTEN OBFUSCATOR V8 (ABYSS) ---
class MelotenObfuscatorV8:
    def __init__(self, source, layers=1):
        self.original_source = source
        self.layers = layers
        
    def _n(self):
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∑–∞–ø—É—Ç–∞–Ω–Ω—ã–µ –∏–º–µ–Ω–∞"""
        length = random.randint(15, 30)
        suffix = ''.join(random.choices("Il1O0", k=length))
        return f"_{suffix}"

    def _generate_names(self):
        self.key = random.randint(50, 200)
        self.vars = {k: self._n() for k in [
            'vm', 'state', 'bytes', 'idx', 'xor', 'junk', 
            'magic', 'dec', 'len', 'byte_val', 'table', 
            'str_lib', 'bit_lib', 'cache', 'fake'
        ]}

    def _junk_code(self):
        """V8 Junk: –î–æ–±–∞–≤–ª—è–µ—Ç —Ñ–µ–π–∫–æ–≤—ã–µ —Ü–∏–∫–ª—ã –∏ –º–∞—Ç–µ–º–∞—Ç–∏–∫—É"""
        v1 = self.vars['junk']
        ops = [
            f"local {v1} = (5*5)-(20+5);",
            f"if (os.clock() < 0) then while true do end end;", 
            f"-- Opcode: 0x{random.randint(100,999):X}",
            f"local _{random.randint(1,99)} = math.max(1, 0);",
        ]
        return random.choice(ops)

    def _build_layer(self, source_code):
        self._generate_names()
        
        # 1. Base64 + Custom Salt
        b64_source = base64.b64encode(source_code.encode('utf-8')).decode('utf-8')
        
        # 2. Advanced XOR (Key Rotation + Index Mutation)
        raw_bytes = b64_source.encode('utf-8')
        enc_bytes = []
        for i, b in enumerate(raw_bytes):
            mutator = (i * 3) % 200
            dynamic_key = (self.key + mutator) % 255
            val = (b ^ dynamic_key)
            enc_bytes.append(val)
        
        payload = "".join([f"\\{b}" for b in enc_bytes])

        # 3. V8 VM Structure
        vm_script = f"""--[[ Meloten Secure V8 (Abyss) ]]
local {self.vars['str_lib']} = string
local {self.vars['table']} = table
local {self.vars['bit_lib']} = bit32 or require('bit')

local function {self.vars['xor']}(a, b)
    if {self.vars['bit_lib']} then return {self.vars['bit_lib']}.bxor(a, b) end
    local p,c=1,0
    while a>0 and b>0 do
        local ra,rb=a%2,b%2; if ra~=rb then c=c+p end
        a,b,p=(a-ra)/2,(b-rb)/2,p*2
    end
    if a<b then a=b end
    while a>0 do local ra=a%2; if ra>0 then c=c+p end a,p=(a-ra)/2,p*2 end
    return c
end

local function {self.vars['vm']}({self.vars['bytes']})
    local {self.vars['state']} = 1000 -- Start
    local {self.vars['dec']} = {{}}
    local {self.vars['idx']} = 1
    local {self.vars['len']} = #{self.vars['bytes']}
    local {self.vars['magic']} = {self.key}
    local {self.vars['fake']} = 0
    
    while {self.vars['state']} ~= 0 do
        {self._junk_code()}
        
        if {self.vars['state']} == 1000 then
            {self.vars['idx']} = 1
            {self.vars['state']} = 750
            
        elseif {self.vars['state']} == 750 then
            -- Check Loop
            if {self.vars['idx']} <= {self.vars['len']} then
                {self.vars['state']} = 500
            else
                {self.vars['state']} = 999 -- End
            end
        
        elseif {self.vars['state']} == 1234 then 
            -- FAKE STATE (Never executed)
            while true do end
            
        elseif {self.vars['state']} == 500 then
            -- Decryption Logic V8
            local {self.vars['byte_val']} = {self.vars['str_lib']}.byte({self.vars['bytes']}, {self.vars['idx']})
            local mut = ({self.vars['idx']} - 1) * 3 % 200
            local dyn = ({self.vars['magic']} + mut) % 255
            local clean = {self.vars['xor']}({self.vars['byte_val']}, dyn)
            
            {self.vars['table']}.insert({self.vars['dec']}, {self.vars['str_lib']}.char(clean))
            {self.vars['idx']} = {self.vars['idx']} + 1
            {self.vars['state']} = 750
            
        elseif {self.vars['state']} == 999 then
             -- Anti-Hook / Anti-Tamper check before return
             if ({self.vars['str_lib']} ~= string) then while true do end end
             {self.vars['state']} = 0
        end
    end
    
    return {self.vars['table']}.concat({self.vars['dec']})
end

local _payload = "{payload}"
local _res = {self.vars['vm']}(_payload)

-- Base64 Decode
local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
local function _d(d)
    d = string.gsub(d, '[^'..b..'=]', '')
    return (d:gsub('.', function(x)
        if (x == '=') then return '' end
        local r,f='',(b:find(x)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end

local _final = _d(_res)
local _load = loadstring or load
if getgenv then getgenv().SCRIPT_OWNER = "Meloten" end
pcall(_load(_final))
"""
        return vm_script

    def build(self):
        code = self.original_source
        for _ in range(self.layers):
            code = self._build_layer(code)
        return code

# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò ---

@dp.message(Command("start"))
async def start(message: types.Message):
    await message.answer(
        "üõ° **Meloten Obfuscator V8 (Abyss)**\n\n"
        "üî• **–§—É–Ω–∫—Ü–∏–∏:**\n"
        "1Ô∏è‚É£ –°–∫–∏–Ω—å `.lua` ‚Äî –∑–∞—â–∏—â—É (V8 Abyss).\n"
        "2Ô∏è‚É£ `/beautify` (—Å —Ñ–∞–π–ª–æ–º) ‚Äî —É–ª—É—á—à—É –∫–æ–¥.\n"
        "3Ô∏è‚É£ `/loadstring <url>` ‚Äî –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä.\n"
        "4Ô∏è‚É£ `/ping` ‚Äî –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏.\n\n"
        "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏: `/setlayers 1-3`\n"
        "üì¢ –ö–∞–Ω–∞–ª: @MelotenBot",
        parse_mode="Markdown"
    )

@dp.message(Command("help"))
async def help_cmd(message: types.Message):
    await message.answer(
        "üìö **–ú–µ–Ω—é –ø–æ–º–æ—â–∏:**\n\n"
        "üñ• **–û—Å–Ω–æ–≤–Ω—ã–µ:**\n"
        "‚Ä¢ `/start` ‚Äî –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫\n"
        "‚Ä¢ `/ping` ‚Äî –£–∑–Ω–∞—Ç—å –ø–∏–Ω–≥ –±–æ—Ç–∞\n"
        "‚Ä¢ `/loadstring <url>` ‚Äî –°–æ–∑–¥–∞—Ç—å Remote Loadstring\n\n"
        "üõ† **–†–∞–±–æ—Ç–∞ —Å –∫–æ–¥–æ–º:**\n"
        "‚Ä¢ `/beautify` ‚Äî –û—Ç–ø—Ä–∞–≤—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É –í–ú–ï–°–¢–ï —Å —Ñ–∞–π–ª–æ–º (–≤ –æ–ø–∏—Å–∞–Ω–∏–∏), —á—Ç–æ–±—ã –≤—ã—Ä–æ–≤–Ω—è—Ç—å –∫—Ä–∏–≤–æ–π –∫–æ–¥.\n"
        "‚Ä¢ **–ü—Ä–æ—Å—Ç–æ —Ñ–∞–π–ª** ‚Äî –û—Ç–ø—Ä–∞–≤—å —Ñ–∞–π–ª –¥–ª—è –æ–±—Ñ—É—Å–∫–∞—Ü–∏–∏.\n\n"
        "üõ° **–ó–∞—â–∏—Ç–∞ V8:**\n"
        "‚Ä¢ `/setlayers <1-3>` ‚Äî –í—ã–±–æ—Ä —Å–∏–ª—ã –∑–∞—â–∏—Ç—ã.\n",
        parse_mode="Markdown"
    )

@dp.message(Command("ping"))
async def ping_handler(message: types.Message):
    start_time = time.time()
    msg = await message.answer("üì∂ **Pinging...**", parse_mode="Markdown")
    end_time = time.time()
    ping_ms = int((end_time - start_time) * 1000)
    await msg.edit_text(f"üì∂ **Pong!**\n–ó–∞–¥–µ—Ä–∂–∫–∞: `{ping_ms}ms`", parse_mode="Markdown")

@dp.message(Command("setlayers"))
async def set_layers(message: types.Message, command: CommandObject):
    if not command.args:
        await message.answer("‚ö†Ô∏è –ü—Ä–∏–º–µ—Ä: `/setlayers 2`")
        return
    
    # –ü–†–û–í–ï–†–ö–ê –ù–ê –ü–†–ï–ú–ò–£–ú (–í–õ–ê–î–ï–õ–ï–¶)
    is_premium = (message.from_user.username == "Gokuoriginal")
    max_limit = 10 if is_premium else 3
    
    try:
        n = int(command.args)
        if 1 <= n <= max_limit:
            user_settings[message.from_user.id] = n
            await message.answer(f"‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ —Å–ª–æ–µ–≤ –∑–∞—â–∏—Ç—ã V8: **{n}**")
        else:
            await message.answer(f"‚ö†Ô∏è –õ–∏–º–∏—Ç: 1-{max_limit} —Å–ª–æ—è.")
    except:
        await message.answer("‚ö†Ô∏è –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.")

@dp.message(Command("loadstring"))
async def make_loadstring(message: types.Message, command: CommandObject):
    if not command.args:
        await message.answer("‚ö†Ô∏è –ü—Ä–∏–º–µ—Ä: `/loadstring https://...`")
        return
    url = command.args.strip()
    content = f'loadstring(game:HttpGet("{url}"))()'
    # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ–∫—Å—Ç–∞ –≤–º–µ—Å—Ç–æ —Ñ–∞–π–ª–∞
    await message.answer(f"‚úÖ **Loadstring –≥–æ—Ç–æ–≤:**\n\n`{content}`", parse_mode="Markdown")

@dp.message(F.document)
async def handle_files(message: types.Message):
    if not message.document.file_name.endswith(('.lua', '.txt')):
        return

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ Beautify (–µ—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ –≤ caption)
    is_beautify = (message.caption and "/beautify" in message.caption)
    
    file_id = message.document.file_id
    file_info = await bot.get_file(file_id)
    downloaded = await bot.download_file(file_info.file_path)
    source_code = downloaded.read().decode('utf-8', errors='ignore')

    if is_beautify:
        # –†–µ–∂–∏–º –£–ª—É—á—à–µ–Ω–∏—è –∫–æ–¥–∞
        status = await message.answer("‚ú® **–£–ª—É—á—à–∞—é –∫–æ–¥ (Beautify)...**", parse_mode="Markdown")
        try:
            beauty = LuaBeautifier(source_code)
            formatted_code = beauty.format()
            
            out = BufferedInputFile(formatted_code.encode(), filename=f"Clean_{message.document.file_name}")
            await message.answer_document(out, caption="‚ú® **–ö–æ–¥ –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω!**\n–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω.")
            await status.delete()
        except Exception as e:
            await message.answer(f"‚ùå –û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")
        return

    # –†–µ–∂–∏–º –û–±—Ñ—É—Å–∫–∞—Ü–∏–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
    layers = user_settings.get(message.from_user.id, 1)
    status = await message.answer(f"üîí **–ó–∞—â–∏—Ç–∞ V8 (Abyss) | Layers: {layers}...**", parse_mode="Markdown")
    
    try:
        obf = MelotenObfuscatorV8(source_code, layers=layers)
        protected_code = obf.build()
        
        out = BufferedInputFile(protected_code.encode(), filename=f"Protected_{message.document.file_name}")
        await message.answer_document(out, caption=f"‚úÖ **–ì–æ—Ç–æ–≤–æ (V8 Abyss)**\nüõ° Layers: {layers}\n‚ò†Ô∏è Fake Opcodes: Active")
        await status.delete()
        
    except Exception as e:
        logging.error(e)
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {e}")

async def main():
    print("--- MELOTEN V8 ABYSS STARTED ---")
    await dp.start_polling(bot)

if __name__ == '__main__':
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("Bot off")
